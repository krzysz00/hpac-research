@article{Krebber2017,
abstract = {Pattern matching is a powerful tool which is part of many functional programming languages as well as computer algebra systems such as Mathematica. Among the existing systems, Mathematica offers the most expressive pattern matching. Unfortunately, no open source alternative has comparable pattern matching capabilities. Notably, these features include support for associative and/or commutative function symbols and sequence variables. While those features have individually been subject of previous research, their comprehensive combination has not yet been investigated. Furthermore, in many applications, a fixed set of patterns is matched repeatedly against different subjects. This many-to-one matching can be sped up by exploiting similarities between patterns. Discrimination nets are the state-of-the-art solution for many-to-one matching. In this thesis, a generalized discrimination net which supports the full feature set is presented. All algorithms have been implemented as an open-source library for Python. In experiments on real world examples, significant speedups of many-to-one over one-to-one matching have been observed.},
archivePrefix = {arXiv},
arxivId = {1705.00907},
author = {Krebber, Manuel},
eprint = {1705.00907},
file = {:home/krzys/Documents/fall-2017/papers/Non-linear Associative-Commutative Many-to-One Pattern Matching with Sequence Variables - Krebber.pdf:pdf},
title = {{Non-linear Associative-Commutative Many-to-One Pattern Matching with Sequence Variables}},
url = {http://arxiv.org/abs/1705.00907},
year = {2017}
}
@article{Lankford1989,
author = {Lankford, Dallas},
file = {:home/krzys/Documents/fall-2017/papers/Non-negative Integer Basis Algorithms for Linear Equations with Integer Coefficients - Lankford.pdf:pdf},
journal = {Journal of Automated Reasomng},
keywords = {associative-commutative unification,integer basis algorithms,linear equations},
pages = {25--35},
title = {{Non-negative Integer Basis Algorithms for Linear Equations with Integer Coefficients}},
volume = {5},
year = {1989}
}
@article{Wehrman2006,
abstract = {A Knuth-Bendix completion procedure is parametrized by a reduction ordering used to ensure termination of intermediate and resulting rewriting systems. While in principle any reduction ordering can be used, modern completion tools typically implement only Knuth-Bendix and path orderings. Consequently, the theories for which completion can possibly yield a decision procedure are limited to those that can be oriented with a single path order. In this paper, we present a variant on the Knuth-Bendix completion procedure in which no ordering is assumed. Instead we rely on a modern termination checker to verify termination of rewriting systems. The new method is correct if it terminates; the resulting rewrite system is convergent and equivalent to the input theory. Completions are also not just ground-convergent, but fully convergent. We present an implementation of the new procedure, Slothrop, which automatically obtains such completions for theories that do not admit path orderings.},
author = {Wehrman, Ian and Stump, Aaron and Westbrook, Edwin},
doi = {10.1007/11805618_22},
file = {:home/krzys/Documents/fall-2017/papers/Slothrop Knuth-Bendix completion with a modern termination checker - Wehrman, Stump, Westbrook.pdf:pdf},
isbn = {3540368345},
issn = {16113349},
journal = {Term Rewriting and Applications},
pages = {287--296},
title = {{Slothrop: Knuth-Bendix completion with a modern termination checker}},
url = {http://link.springer.com/chapter/10.1007/11805618{\_}22},
volume = {4098},
year = {2006}
}
@article{Marchiori1997,
abstract = {The class of Deterministic Conditional Term Rewriting Systems (DCTRSs) is of utmost importance for the tight relationships exhibited with functional programming, logic programming and inductive reasoning. However, its analysis is extremely difficult, and to date there are only very few works on the subject, each analyzing a particular aspect of DCTRSs. In this paper, we perform a thorough analysis of DCTRSs, ranging from the study of termination criteria, to new verification methods for the major properties of DCTRSs like termination and confluence, to the identification of subclasses of DTCRSs that exhibit a particularly nice behaviour. Moreover, we also address the study of modularity of DCTRSs, providing a numberofnewpowerful results. This is particularly important, since to the best of our knowledge there is so far not a single result on the modularity of DCTRSs, and of 3-CTRSs in general. Finally, most of the analysis of the paper is performed relying on the recenttoolofunravelings, that allows to automatically lift results from the much simpler unconditional rewriting systems to DCTRSs. This way,we clarify what are the links between TRSs and DCTRSs, providing better intuitions on how the gained experience on TRSs can be profitably reused to understand the much more complicated world of DCTRSs.},
author = {Marchiori, Massimo},
file = {:home/krzys/Documents/fall-2017/papers/On deterministic conditional rewriting - Marchiori.pdf:pdf},
journal = {Mit Laboratory for Computer Science},
title = {{On deterministic conditional rewriting}},
url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.59.5251},
volume = {405},
year = {1997}
}
@article{Selsam2017,
abstract = {Noisy data, non-convex objectives, model misspecification, and numerical instability can all cause undesired behaviors in machine learning systems. As a result, detecting actual implementation errors can be extremely difficult. We demonstrate a methodology in which developers use an interactive proof assistant to both implement their system and to state a formal theorem defining what it means for their system to be correct. The process of proving this theorem interactively in the proof assistant exposes all implementation errors since any error in the program would cause the proof to fail. As a case study, we implement a new system, Certigrad, for optimizing over stochastic computation graphs, and we generate a formal (i.e. machine-checkable) proof that the gradients sampled by the system are unbiased estimates of the true mathematical gradients. We train a variational autoencoder using Certigrad and find the performance comparable to training the same model in TensorFlow.},
archivePrefix = {arXiv},
arxivId = {1706.08605},
author = {Selsam, Daniel and Liang, Percy and Dill, David L.},
eprint = {1706.08605},
file = {:home/krzys/Documents/fall-2017/papers/Developing Bug-Free Machine Learning Systems With Formal Mathematics - Selsam, Liang, Dill.pdf:pdf},
title = {{Developing Bug-Free Machine Learning Systems With Formal Mathematics}},
url = {http://arxiv.org/abs/1706.08605},
year = {2017}
}
@article{Dick1991,
abstract = {An informal introduction is given to the underlying concepts of term rewriting. Topics covered are Knuth-Bendix completion, completion modulo equations, unfailing completion and theorem proving by completion.},
author = {Dick, A J J},
doi = {10.1093/comjnl/34.1.2},
file = {:home/krzys/Documents/fall-2017/papers/An Introduction to Knuth-Bendix Completion - Dick.pdf:pdf},
issn = {0010-4620},
journal = {The Computer Journal},
number = {1},
pages = {2--15},
title = {{An Introduction to Knuth-Bendix Completion}},
url = {http://comjnl.oxfordjournals.org/content/34/1/2.abstract{\%}5Cnhttp://comjnl.oxfordjournals.org/content/34/1/2.full.pdf{\%}5Cnhttp://comjnl.oxfordjournals.org/cgi/content/abstract/34/1/2},
volume = {34},
year = {1991}
}
@article{Goguen1985,
author = {Goguen, J . A and Meseguer, J},
file = {:home/krzys/Documents/fall-2017/papers/Completeness of Many-Sorted Equational Logic - Goguen, Meseguer.pdf:pdf},
journal = {Houston Journal of Mathematics},
number = {3},
pages = {307--334},
title = {{Completeness of Many-Sorted Equational Logic}},
volume = {11},
year = {1985}
}
@article{Dick1990,
abstract = {Knuth and Bendix proposed a very versatile technique for ordering terms, based upon assigning weights to operators and then to terms by adding up the weights of the operators they contain. Our purpose in this paper is as follows. First we give some examples to indicate the flexibility of the method. Then we give a simple and practical algorithm, based on solving systems of linear inequalities, for determining whether or not a set of rules can be ordered by a Knuth Bendix ordering. We also describe how this algorithm may be incorporated in a completion procedure which thus considers all possible choices of weights which orient a given equation. 1.},
author = {Dick, Jeremy and Kalmus, John and Martin, Ursula},
doi = {10.1007/BF01237233},
file = {:home/krzys/Documents/fall-2017/papers/Automating the Knuth Bendix ordering - Dick, Kalmus, Martin.pdf:pdf},
issn = {00015903},
journal = {Acta Informatica},
number = {2},
pages = {95--119},
title = {{Automating the Knuth Bendix ordering}},
volume = {28},
year = {1990}
}
@book{Bachmair1991,
author = {Bachmair, Leo},
file = {:home/krzys/Documents/fall-2017/papers/Canonical Equational Proofs - Bachmair.pdf:pdf},
isbn = {9780817635558},
publisher = {Birkh{\"{a}}user Basel},
title = {{Canonical Equational Proofs}},
year = {1991}
}
@techreport{Stickel,
author = {Stickel, Mark E.},
file = {:home/krzys/Documents/fall-2017/papers/A Complete Unification Algorithm For Associative-Commutative Functions - Stickel.pdf:pdf},
title = {{A Complete Unification Algorithm For Associative-Commutative Functions}}
}
@article{Lewis2017,
archivePrefix = {arXiv},
arxivId = {1712.09288},
author = {Lewis, Robert Y},
doi = {10.4204/EPTCS.262.4},
eprint = {1712.09288},
file = {:home/krzys/Documents/fall-2017/papers/An extensible ad hoc interface between Lean and Mathematica - Lewis.pdf:pdf},
issn = {2075-2180},
title = {{An extensible ad hoc interface between Lean and Mathematica}},
year = {2017}
}
@unpublished{LeanIntro2017,
author = {Avigad, Jeremy and de Moura, Loanardo and Ebner, Gabriel and Ullrich, Sebastian},
file = {:home/krzys/Documents/fall-2017/papers/An introduction to Lean - Avigad et al.pdf:pdf},
pages = {1--47},
title = {{An introduction to Lean}},
url = {https://leanprover.github.io/introduction{\_}to{\_}lean/introduction{\_}to{\_}lean.pdf},
year = {2017}
}
@article{Avigad2017,
abstract = {Version 1389e64, updated at 2017-01-03 16:05:59 +1100 2 Copyright (c) 2014–2015, Jeremy Avigad, Leonardo de Moura, and Soonho Kong. All rights reserved. Released under Apache 2.0 license as described in the file LICENSE.},
author = {Avigad, Jeremy and {De Moura}, Leonardo and Kong, Soonho},
file = {:home/krzys/Documents/fall-2017/papers/Theorem Proving in Lean - Avigad, De Moura, Kong.pdf:pdf},
title = {{Theorem Proving in Lean}},
year = {2017}
}
@book{Baader1998,
abstract = {This textbook offers a unified, self-contained introduction to the field of term rewriting. Baader and Nipkow cover all the basic material-abstract reduction systems, termination, confluence, completion, and combination problems-but also some important and closely connected subjects: universal algebra, unification theory, Gr{\"{o}}bner bases, and Buchberger's algorithm. They present the main algorithms both informally and as programs in the functional language Standard ML (An appendix contains a quick and easy introduction to ML). Key chapters cover crucial algorithms such as unification and congruence closure in more depth and develop efficient Pascal programs. The book contains many examples and over 170 exercises. This is also an ideal reference book for professional researchers: results spread over many conference and journal articles are collected here in a unified notation, detailed proofs of almost all theorems are provided, and each chapter closes with a guide to the literature.},
author = {Baader, Franz and Nipkow, Tobias},
booktitle = {Term Rewriting and All That},
file = {:home/krzys/Documents/fall-2017/papers/[Franz{\_}Baader,{\_}Tobias{\_}Nipkow]{\_}Term{\_}rewriting{\_}and{\_}a(BookFi).djvu:djvu},
isbn = {978-0521779203},
issn = {14625970},
number = {1},
pages = {40},
title = {{Term Rewriting and All That}},
url = {http://books.google.com/books?hl=de{\&}lr={\&}id=N7BvXVUCQk8C{\&}pgis=1},
volume = {145},
year = {1998}
}
@article{Plaisted1998,
abstract = {The Handbook of Logic in Artificial Intelligence and Logic Programming is a multi-volume work covering all major areas of the application of logic to artificial intelligence and logic programming. The authors are chosen on an international basis and are leaders in the fields covered. Volume 5 is the last in this well-regarded series. Logic is now widely recognized as one of the foundational disciplines of computing. It has found applications in virtually all aspects of the subject, from software and hardware engineering to programming languages and artificial intelligence. In response to the growing need for an in-depth survey of these applications the Handbook of Logic in Artificial Intelligence and its companion, the Handbook of Logic in Computer Science have been created. The Handbooks are a combination of authoritative exposition, comprehensive survey, and fundamental research exploring the underlying themes in the various areas. Some mathematical background is assumed, and much of the material will be of interest to logicians and mathematicians. Volume 5 focuses particularly on logic programming.; The chapters, which in many cases are of monograph length and scope, emphasize possible unifying themes.},
author = {Plaisted, David A.},
file = {:home/krzys/Documents/fall-2017/papers/Equational reasoning and term rewriting systems - Plaisted.pdf:pdf},
isbn = {019853745X},
journal = {Handbook of logic in artificial intelligence and logic programming (vol. 1)},
pages = {274--364},
title = {{Equational reasoning and term rewriting systems}},
year = {1998}
}
@article{Ganzinger1991,
abstract = {Order-sorted specifications can be transformed into equivalent many-sorted ones by using injections to implement subsort relations. In this paper we improve previous results about the relation between order-sorted and many-sorted rewriting. We then apply techniques for the completion of many-sorted conditional equations to systems obtained from translating order-sorted conditional equations. Emphasis will be on ways to overcome some of the problems with non-sort-decreasing rules. {\textcopyright} 1991.},
author = {Ganzinger, Harald},
doi = {10.1016/0304-3975(90)90105-Q},
file = {:home/krzys/Documents/fall-2017/papers/Order-sorted completion the many-sorted way - Ganzinger.pdf:pdf},
issn = {03043975},
journal = {Theoretical Computer Science},
number = {1},
pages = {3--32},
title = {{Order-sorted completion: the many-sorted way}},
volume = {89},
year = {1991}
}
@article{Peterson1981,
abstract = {An extenston of the Knuth-Bendix algorithm for finding complete sets of reductions is described. The extension is intended to handle equational theories which can be split into two parts, R and T, such that each equation m R can be construed as a reduction and T represents an equational theory for which a finite, complete umficat{\~{}}on algorithm {\~{}}s known. The extension ts demonstrated in the case when T is the theory of a fimte number of associaUve and commutatwe functions and to which the extension is presently restricted An tmplementatlon of the extended Knuth-Bendtx algorithm has produced complete sets of reductions for free commutattve groups, commutative rings wtth umt, and distributive lattices. KEY WORDS AND PHRASES complete sets of reductions, equational theories, complete unification algo-rithms, assocmave and commutauv¢ funcuons, umque termmatton property, finite terminaUon property, simplification, theorem proving, well-founded partml order, commutative group, commutatwe ring, lattice, Boolean algebra CR CATEGORIES: 3 64, 3.66, 5 21},
author = {Peterson, Gerald E. and Stickel, Mark E.},
doi = {10.1145/322248.322251},
file = {:home/krzys/Documents/fall-2017/papers/Complete Sets of Reductions for Some Equational Theories - Peterson, Stickel.pdf:pdf},
issn = {0004-5411},
journal = {Journal of the Association Computing Machinery},
keywords = {and phrases complete sets,assocmave and commutauv,commutative group,commutatwe ring,complete unification algo-,equational theories,finite terminauon property,funcuons,lattice,of reductions,rithms,simplification,theorem proving,umque termmatton property,well-founded partml order},
number = {2},
pages = {233--264},
title = {{Complete Sets of Reductions for Some Equational Theories}},
volume = {28},
year = {1981}
}
@inproceedings{Plaisted,
author = {Plaisted, David A},
booktitle = {International Conference on Automated Deduction.},
file = {:home/krzys/Documents/fall-2017/papers/A simple non-termination test for the Knuth-Bendix method - Plaisted.pdf:pdf},
title = {{A simple non-termination test for the Knuth-Bendix method}},
year = {1986}
}
@article{Dershowitz1987,
abstract = {This survey describes methods for proving that systems of rewrite rules are terminating programs. We illustrate the use in termination proofs of various kinds of orderings on terms, including polynomial interpretations and path orderings. The effect of restrictions, such as linearity, on the form of rules is also considered. In general, however, termination is an undecidable property of rewrite systems. {\textcopyright} 1987, Academic Press Inc. (London) Ltd.. All rights reserved.},
author = {Dershowitz, Nachum},
doi = {10.1016/S0747-7171(87)80022-6},
file = {:home/krzys/Documents/fall-2017/papers/Termination of rewriting - Dershowitz.pdf:pdf},
issn = {07477171},
journal = {Journal of Symbolic Computation},
number = {1-2},
pages = {69--115},
title = {{Termination of rewriting}},
volume = {3},
year = {1987}
}
@article{Lincoln1989,
abstract = {We have discovered an efficient algorithm for matching and unification in associative-commutative (AC) equational theories. In most cases of AC unification our method obviates the need for solving diophantine equations, and thus avoids one of the bottlenecks of other associative-commutative unification techniques. The algorithm efficiently utilizes powerful constraints to eliminate much of the search involved in generating valid substitutions. Moreover, it is able to generate solutions lazily, enabling its use in an SLD-resolution-based environment like Prolog. We have found the method to run much faster and use less space than other associative-commutative unification procedures on many commonly encountered AC problems. {\textcopyright} 1989, Academic Press Limited. All rights reserved.},
author = {Lincoln, Patrick and Christian, Jim},
doi = {10.1016/S0747-7171(89)80026-4},
file = {:home/krzys/Documents/fall-2017/papers/Adventures in associative-commutative unification - Lincoln, Christian.pdf:pdf},
issn = {07477171},
journal = {Journal of Symbolic Computation},
number = {1-2},
pages = {217--240},
title = {{Adventures in associative-commutative unification}},
volume = {8},
year = {1989}
}
