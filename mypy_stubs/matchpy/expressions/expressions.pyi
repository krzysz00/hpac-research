# Stubs for matchpy.expressions.expressions (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from abc import ABCMeta
from multiset import Multiset
from typing import (Any, List, Tuple, Type, Union,
                    Optional, Callable, Iterator, NamedTuple)


__all__ = [
    'Expression', 'Arity', 'Atom', 'Symbol', 'Wildcard', 'Operation', 'SymbolWildcard', 'Pattern', 'make_dot_variable',
    'make_plus_variable', 'make_star_variable', 'make_symbol_variable', 'AssociativeOperation', 'CommutativeOperation',
    'OneIdentityOperation'
]

MultisetOfStr = Multiset
MultisetOfVariables = Multiset

ExprPredicate = Optional[Callable[['Expression'], bool]]
ExpressionsWithPos = Iterator[Tuple['Expression', Tuple[int, ...]]]

class Expression:
    variable_name: Any = ...
    def __init__(self, variable_name) -> None: ...
    def variables(self) -> MultisetOfVariables: ...
    def collect_variables(self, variables: MultisetOfVariables) -> None: ...
    def symbols(self) -> MultisetOfStr: ...
    def collect_symbols(self, symbols: MultisetOfStr) -> None: ...
    def is_constant(self) -> bool: ...
    def is_syntactic(self) -> bool: ...
    def with_renamed_vars(self, renaming: Any) -> Expression: ...
    def preorder_iter(self, predicate: ExprPredicate=...) -> ExpressionsWithPos: ...
    def __getitem__(self, position: Union[Tuple[int, ...], slice]) -> Expression: ...
    def __contains__(self, expression: Expression) -> bool: ...
    def __hash__(self): ...

_ArityBase = NamedTuple('_ArityBase', [('min_count', int), ('fixed_size', bool)])
class Arity(_ArityBase): ...

class _OperationMeta(ABCMeta):
    def __init__(cls, name, bases, dct) -> None: ...
    def __call__(cls: Any, *operands: Expression, variable_name: Any=...) -> Any: ...  # type: ignore

class Operation(Expression):
    name: str = ...
    arity: Arity = ...
    associative: bool = ...
    commutative: bool = ...
    one_identity: bool = ...
    infix: bool = ...
    operands: Any = ...
    def __init__(self, operands: List[Expression], variable_name: Any=...) -> None: ...
    @staticmethod
    def new(name: str, arity: Arity, class_name: str=..., *, associative: bool=..., commutative: bool=..., one_identity: bool=..., infix: bool=...) -> Type[Operation]: ...
    def __lt__(self, other): ...
    def __eq__(self, other): ...
    def __iter__(self): ...
    def __len__(self): ...
    def __getitem__(self, key: Union[Tuple[int, ...], slice]) -> Expression: ...
    def __contains__(self, expression: Expression) -> bool: ...
    def collect_variables(self, variables: Any) -> None: ...
    def collect_symbols(self, symbols: Any) -> None: ...
    def __hash__(self): ...
    def with_renamed_vars(self, renaming: Any) -> Operation: ...
    def __copy__(self) -> Operation: ...

class AssociativeOperation:
    @classmethod
    def __subclasshook__(cls, C): ...

class CommutativeOperation:
    @classmethod
    def __subclasshook__(cls, C): ...

class OneIdentityOperation:
    @classmethod
    def __subclasshook__(cls, C): ...

class Atom(Expression):
    __iter__: Any = ...

class Symbol(Atom):
    name: Any = ...
    head: Any = ...
    def __init__(self, name: str, variable_name: Any=...) -> None: ...
    def collect_symbols(self, symbols): ...
    def with_renamed_vars(self, renaming: Any) -> Symbol: ...
    def __copy__(self) -> Symbol: ...
    def __lt__(self, other): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class Wildcard(Atom):
    head: Any = ...
    min_count: Any = ...
    fixed_size: Any = ...
    optional: Any = ...
    def __init__(self, min_count: int, fixed_size: bool, variable_name: Any=..., optional: Any=...) -> None: ...
    def with_renamed_vars(self, renaming: Any) -> Wildcard: ...
    @staticmethod
    def dot(name: Any=...) -> Wildcard: ...
    @staticmethod
    def optional(name: Any, default: Any) -> Wildcard: ...
    @staticmethod
    def symbol(name: str=..., symbol_type: Type[Symbol]=...) -> SymbolWildcard: ...
    @staticmethod
    def star(name: Any=...) -> Wildcard: ...
    @staticmethod
    def plus(name: Any=...) -> Wildcard: ...
    def __lt__(self, other): ...
    def __eq__(self, other): ...
    def __hash__(self): ...
    def __copy__(self) -> Wildcard: ...

class SymbolWildcard(Wildcard):
    symbol_type: Any = ...
    def __init__(self, symbol_type: Type[Symbol]=..., variable_name: Any=...) -> None: ...
    def with_renamed_vars(self, renaming: Any) -> SymbolWildcard: ...
    def __eq__(self, other): ...
    def __hash__(self): ...
    def __copy__(self) -> SymbolWildcard: ...

class Pattern:
    expression: Any = ...
    constraints: Any = ...
    def __init__(self, expression: Any, *constraints: Any) -> None: ...
    def __eq__(self, other): ...
    @property
    def is_syntactic(self): ...
    @property
    def local_constraints(self): ...
    @property
    def global_constraints(self): ...

def make_dot_variable(name): ...
def make_symbol_variable(name, symbol_type: Any = ...): ...
def make_star_variable(name): ...
def make_plus_variable(name): ...
