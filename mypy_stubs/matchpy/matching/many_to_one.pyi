# Stubs for matchpy.matching.many_to_one (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from .. import functions
from ..expressions.expressions import Expression, Operation, Pattern, Symbol
from ..expressions.substitution import Substitution
from .bipartite import BipartiteGraph
from graphviz import Digraph, Graph
from multiset import Multiset
from typing import Any, Dict, Iterable, Iterator, Optional, Sequence, Tuple, Type, Union

LabelType = Union[Expression, Type[Operation]]
HeadType = Optional[Union[Expression, Type[Operation], Type[Symbol]]]
MultisetOfInt = Multiset
MultisetOfExpression = Multiset

class _MatchIter:
    matcher: Any = ...
    subjects: Any = ...
    patterns: Any = ...
    substitution: Any = ...
    constraints: Any = ...
    associative: Any = ...
    def __init__(self, matcher, subject, intial_associative: Optional[Any] = ...) -> None: ...
    def __iter__(self): ...
    def grouped(self): ...
    def any(self): ...

class ManyToOneMatcher:
    patterns: Any = ...
    states: Any = ...
    root: Any = ...
    pattern_vars: Any = ...
    constraints: Any = ...
    constraint_vars: Any = ...
    finals: Any = ...
    rename: Any = ...
    def __init__(self, *patterns: Expression, rename: Any=...) -> None: ...
    def add(self, pattern: Pattern, label: Any=...) -> None: ...
    def match(self, subject: Expression) -> Iterator[Tuple[Expression, Substitution]]: ...
    def is_match(self, subject: Expression) -> bool: ...
    def as_graph(self) -> Digraph: ...

class ManyToOneReplacer:
    matcher: Any = ...
    def __init__(self, *rules) -> None: ...
    def add(self, rule: functions.ReplacementRule) -> None: ...
    def replace(self, expression: Expression, max_count: int=...) -> Union[Expression, Sequence[Expression]]: ...
    def replace_post_order(self, expression: Expression) -> Union[Expression, Sequence[Expression]]: ...
Subgraph = BipartiteGraph[Tuple[int, int], Tuple[int, int], Substitution]
Matching = Dict[Tuple[int, int], Tuple[int, int]]

class CommutativeMatcher:
    patterns: Any = ...
    subjects: Any = ...
    subjects_by_id: Any = ...
    automaton: Any = ...
    bipartite: Any = ...
    associative: Any = ...
    max_optional_count: int = ...
    anonymous_patterns: Any = ...
    def __init__(self, associative: Optional[type]) -> None: ...
    def add_pattern(self, operands: Iterable[Expression], constraints: Any) -> int: ...
    def get_match_iter(self, subject): ...
    def add_subject(self, subject: Expression) -> None: ...
    def match(self, subjects: Sequence[Expression], substitution: Substitution) -> Iterator[Tuple[int, Substitution]]: ...
    def bipartite_as_graph(self) -> Graph: ...
    def concrete_bipartite_as_graph(self, subjects: Any, patterns: Any) -> Graph: ...

class SecondaryAutomaton:
    k: Any = ...
    states: Any = ...
    def __init__(self, k) -> None: ...
    def match(self, edges): ...
    def as_graph(self): ...
