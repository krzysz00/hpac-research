# Stubs for matchpy.matching.syntactic (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from ..expressions.expressions import Expression, Pattern, Operation, Symbol, Wildcard
from ..expressions.substitution import Substitution
from graphviz import Digraph
from typing import Any, Dict, Generic, Iterator, Sequence, Set, Tuple, TypeVar, Union, Type

T = TypeVar('T')

OPERATION_END = ')'
EPSILON = 'Îµ'
TermAtom = Union[Symbol, Wildcard, Type[Operation], Type[Symbol], str]
TransitionLabel = Union[Symbol, Type[Operation], Type[Symbol], Type[Wildcard], str]

def is_operation(term: Any) -> bool: ...
def is_symbol_wildcard(term: Any) -> bool: ...

class FlatTerm(Sequence[TermAtom]):
    def __init__(self, expression: Union[Expression, Sequence[TermAtom]]) -> None: ...
    def __getitem__(self, index): ...
    def __len__(self): ...
    def __contains__(self, term): ...
    def __iter__(self): ...
    def __add__(self, other): ...
    def __eq__(self, other): ...
    def is_syntactic(self): ...
    @classmethod
    def empty(cls: Any) -> FlatTerm: ...
    @classmethod
    def merged(cls: Any, *flatterms: FlatTerm) -> FlatTerm: ...

class DiscriminationNet(Generic[T]):
    def __init__(self, *patterns: Pattern) -> None: ...
    def add(self, pattern: Union[Pattern, FlatTerm], final_label: T=...) -> int: ...
    def match(self, subject: Union[Expression, FlatTerm]) -> Iterator[Tuple[T, Substitution]]: ...
    def is_match(self, subject: Union[Expression, FlatTerm]) -> bool: ...
    def as_graph(self) -> Digraph: ...

class SequenceMatcher:
    operation: Any = ...
    def __init__(self, *patterns: Pattern) -> None: ...
    def add(self, pattern: Pattern) -> int: ...
    @classmethod
    def can_match(cls: Any, pattern: Pattern) -> bool: ...
    def match(self, subject: Expression) -> Iterator[Tuple[Pattern, Substitution]]: ...
    def as_graph(self) -> Digraph: ...
